@inject ILogger<AudioSetupPanel> Logger
@inject ISnackbar Snackbar
@inject IHttpClientFactory HttpClientFactory
@inject IAudioPlayer AudioPlayer
@inject IRaddyRadioService RaddyRadioService
@inject ISpotifyService SpotifyService
@inject CastAudioOutput CastAudioOutput

<MudPaper Class="pa-4" Style="height: 100%; background-color: #2c2c2c;">
  <MudText Typo="Typo.h5" Class="mb-4">Audio Setup</MudText>
  
  <MudStack Spacing="3">
    <MudDivider />
    <MudText Typo="Typo.h6">Audio Devices</MudText>
    
    <MudSelect T="string" Label="Input Device" Value="@SelectedInputDevice" ValueChanged="OnInputDeviceChanged" Variant="Variant.Outlined">
      @if (AvailableInputDevices.Any())
      {
        @foreach (var device in AvailableInputDevices)
        {
          <MudSelectItem Value="@device.Id">@device.Name @(device.IsDefault ? " (Default)" : "")</MudSelectItem>
        }
      }
      else
      {
        <MudSelectItem Value="@string.Empty" Disabled="true">Loading devices...</MudSelectItem>
      }
    </MudSelect>

    <MudSelect T="string" Label="Output Device" Value="@SelectedOutputDevice" ValueChanged="OnOutputDeviceChanged" Variant="Variant.Outlined">
      @if (AvailableOutputDevices.Any())
      {
        @foreach (var device in AvailableOutputDevices)
        {
          <MudSelectItem Value="@device.Id">@device.Name @(device.IsDefault ? " (Default)" : "")</MudSelectItem>
        }
      }
      else
      {
        <MudSelectItem Value="@string.Empty" Disabled="true">Loading devices...</MudSelectItem>
      }
    </MudSelect>

    <MudDivider />
    <MudText Typo="Typo.h6">Audio Source</MudText>
    
    <MudSelect T="string" Label="Input Source" Value="@SelectedInput" ValueChanged="OnInputChanged" Variant="Variant.Outlined">
      <MudSelectItem Value="@("Radio")">Radio (Raddy RF320)</MudSelectItem>
      <MudSelectItem Value="@("Vinyl")">Vinyl Turntable</MudSelectItem>
      <MudSelectItem Value="@("Spotify")">Spotify</MudSelectItem>
      <MudSelectItem Value="@("Local")">Local MP3s</MudSelectItem>
    </MudSelect>

    <MudSelect T="string" Label="Output Destination" Value="@SelectedOutput" ValueChanged="OnOutputChanged" Variant="Variant.Outlined">
      <MudSelectItem Value="@("Local")">Local Speakers</MudSelectItem>
      <MudSelectItem Value="@("Cast")">Google Cast</MudSelectItem>
    </MudSelect>

    @if (SelectedOutput == "Cast")
    {
      <MudSelect T="string" Label="Cast Device" @bind-Value="SelectedCastDevice" Variant="Variant.Outlined">
        @foreach (var device in AvailableCastDevices)
        {
          <MudSelectItem Value="@device">@device</MudSelectItem>
        }
      </MudSelect>
    }

    <MudDivider />

    <MudText Typo="Typo.h6">Transport Controls</MudText>
    
    <MudStack Row="true" Justify="Justify.Center" Spacing="2">
      <MudIconButton Icon="@Icons.Material.Filled.SkipPrevious" Color="Color.Primary" Size="Size.Large" OnClick="OnPrevious" />
      <MudIconButton Icon="@(IsPlaying ? Icons.Material.Filled.Pause : Icons.Material.Filled.PlayArrow)" 
                     Color="Color.Primary" Size="Size.Large" OnClick="OnPlayPause" />
      <MudIconButton Icon="@Icons.Material.Filled.SkipNext" Color="Color.Primary" Size="Size.Large" OnClick="OnNext" />
      <MudIconButton Icon="@Icons.Material.Filled.Stop" Color="Color.Error" Size="Size.Large" OnClick="OnStop" />
    </MudStack>

    <MudStack Spacing="2">
      <MudText Typo="Typo.body2">Volume</MudText>
      <MudSlider T="int" Value="@Volume" ValueChanged="OnVolumeChanged" Min="0" Max="100" Step="1" Color="Color.Primary" />
      
      <MudText Typo="Typo.body2">Balance</MudText>
      <MudSlider T="int" @bind-Value="Balance" Min="-100" Max="100" Step="1" Color="Color.Primary" />
    </MudStack>
  </MudStack>
</MudPaper>

@code {
    [Parameter]
    public string SelectedInput { get; set; } = "Radio";
    [Parameter]
    public EventCallback<string> SelectedInputChanged { get; set; }
    private string SelectedOutput { get; set; } = "Local";
    private string SelectedCastDevice { get; set; } = "";
    private string SelectedInputDevice { get; set; } = "";
    private string SelectedOutputDevice { get; set; } = "";
    private bool IsPlaying { get; set; } = false;
    private int Volume { get; set; } = 75;
    private int Balance { get; set; } = 0;

    private List<string> AvailableCastDevices { get; set; } = new();
    private List<AudioDeviceInfo> AvailableInputDevices { get; set; } = new();
    private List<AudioDeviceInfo> AvailableOutputDevices { get; set; } = new();
    private HttpClient? _httpClient;

    private async Task OnPlayPause()
    {
        try
        {
            IsPlaying = !IsPlaying;
            if (IsPlaying)
            {
                await PlayCurrentSource();
            }
            else
            {
                await AudioPlayer.StopAsync(SelectedInput);
            }
            Logger.LogInformation("Play/Pause toggled. IsPlaying: {IsPlaying}", IsPlaying);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error toggling play/pause");
            Snackbar.Add("Error toggling play/pause", Severity.Error);
        }
    }

    private async Task OnStop()
    {
        try
        {
            IsPlaying = false;
            await AudioPlayer.StopAsync(SelectedInput);
            Logger.LogInformation("Stop pressed");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error stopping audio");
            Snackbar.Add("Error stopping audio", Severity.Error);
        }
    }

    private async Task OnPrevious()
    {
        try
        {
            switch (SelectedInput)
            {
                case "Spotify":
                    // TODO: Add SkipToPrevious method to ISpotifyService
                    Logger.LogInformation("Previous track requested for Spotify (not yet implemented)");
                    Snackbar.Add("Previous track not yet implemented for Spotify", Severity.Info);
                    break;
                case "Radio":
                    // TODO: Add frequency seek down to IRaddyRadioService
                    Logger.LogInformation("Seek down requested for Radio (not yet implemented)");
                    Snackbar.Add("Seek down not yet implemented for Radio", Severity.Info);
                    break;
                case "Local":
                    // TODO: Implement previous track logic for local files
                    Logger.LogInformation("Previous track requested for Local (not yet implemented)");
                    break;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error going to previous track");
            Snackbar.Add("Error going to previous track", Severity.Error);
        }
    }

    private async Task OnNext()
    {
        try
        {
            switch (SelectedInput)
            {
                case "Spotify":
                    // TODO: Add SkipToNext method to ISpotifyService
                    Logger.LogInformation("Next track requested for Spotify (not yet implemented)");
                    Snackbar.Add("Next track not yet implemented for Spotify", Severity.Info);
                    break;
                case "Radio":
                    // TODO: Add frequency seek up to IRaddyRadioService
                    Logger.LogInformation("Seek up requested for Radio (not yet implemented)");
                    Snackbar.Add("Seek up not yet implemented for Radio", Severity.Info);
                    break;
                case "Local":
                    // TODO: Implement next track logic for local files
                    Logger.LogInformation("Next track requested for Local (not yet implemented)");
                    break;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error going to next track");
            Snackbar.Add("Error going to next track", Severity.Error);
        }
    }

    private async Task PlayCurrentSource()
    {
        try
        {
            // TODO: Integrate with actual audio streaming from services
            // For now, log the action
            Logger.LogInformation("Play requested for source: {Source}", SelectedInput);
            
            switch (SelectedInput)
            {
                case "Radio":
                    await RaddyRadioService.StartAsync();
                    Snackbar.Add("Radio playback started", Severity.Success);
                    break;
                case "Spotify":
                    if (SpotifyService.IsAuthenticated)
                    {
                        await SpotifyService.ResumeAsync();
                        Snackbar.Add("Spotify playback started", Severity.Success);
                    }
                    else
                    {
                        Snackbar.Add("Spotify not authenticated", Severity.Warning);
                    }
                    break;
                case "Vinyl":
                    // TODO: Implement Vinyl playback
                    Snackbar.Add("Vinyl playback not yet implemented", Severity.Info);
                    break;
                case "Local":
                    // TODO: Implement local file playback
                    Snackbar.Add("Local file playback not yet implemented", Severity.Info);
                    break;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error playing audio source");
            Snackbar.Add("Error playing audio source", Severity.Error);
        }
    }

    protected override async Task OnInitializedAsync()
    {
        _httpClient = HttpClientFactory.CreateClient("API");
        
        if (!AudioPlayer.IsInitialized)
        {
            await AudioPlayer.InitializeAsync("default");
        }
        await LoadAudioDevices();
        await LoadCastDevices();
        // TODO: Load current audio settings
    }

    private async Task LoadAudioDevices()
    {
        if (_httpClient == null) return;
        
        try
        {
            var inputDevices = await _httpClient.GetFromJsonAsync<List<AudioDeviceInfo>>("/api/audiodevicemanager/inputs");
            if (inputDevices != null)
            {
                AvailableInputDevices = inputDevices;
                
                // Try to get current input device
                try
                {
                    var currentInput = await _httpClient.GetFromJsonAsync<AudioDeviceInfo>("/api/audiodevicemanager/inputs/current");
                    if (currentInput != null)
                    {
                        SelectedInputDevice = currentInput.Id;
                    }
                }
                catch
                {
                    // No current device selected, use default or first
                    SelectedInputDevice = AvailableInputDevices.FirstOrDefault(d => d.IsDefault)?.Id 
                                        ?? AvailableInputDevices.FirstOrDefault()?.Id 
                                        ?? "";
                }
            }

            var outputDevices = await _httpClient.GetFromJsonAsync<List<AudioDeviceInfo>>("/api/audiodevicemanager/outputs");
            if (outputDevices != null)
            {
                AvailableOutputDevices = outputDevices;
                
                // Try to get current output device
                try
                {
                    var currentOutput = await _httpClient.GetFromJsonAsync<AudioDeviceInfo>("/api/audiodevicemanager/outputs/current");
                    if (currentOutput != null)
                    {
                        SelectedOutputDevice = currentOutput.Id;
                    }
                }
                catch
                {
                    // No current device selected, use default or first
                    SelectedOutputDevice = AvailableOutputDevices.FirstOrDefault(d => d.IsDefault)?.Id 
                                         ?? AvailableOutputDevices.FirstOrDefault()?.Id 
                                         ?? "";
                }
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading audio devices");
            Snackbar.Add("Error loading audio devices", Severity.Warning);
        }
    }

    private async Task OnInputDeviceChanged(string deviceId)
    {
        if (_httpClient == null || string.IsNullOrEmpty(deviceId)) return;
        
        try
        {
            var request = new { DeviceId = deviceId };
            var response = await _httpClient.PostAsJsonAsync("/api/audiodevicemanager/inputs/current", request);
            response.EnsureSuccessStatusCode();
            
            SelectedInputDevice = deviceId;
            var deviceName = AvailableInputDevices.FirstOrDefault(d => d.Id == deviceId)?.Name ?? "Unknown";
            Snackbar.Add($"Input device changed to: {deviceName}", Severity.Success);
            Logger.LogInformation("Input device changed to: {DeviceId}", deviceId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error changing input device");
            Snackbar.Add("Error changing input device", Severity.Error);
        }
    }

    private async Task OnOutputDeviceChanged(string deviceId)
    {
        if (_httpClient == null || string.IsNullOrEmpty(deviceId)) return;
        
        try
        {
            var request = new { DeviceId = deviceId };
            var response = await _httpClient.PostAsJsonAsync("/api/audiodevicemanager/outputs/current", request);
            response.EnsureSuccessStatusCode();
            
            SelectedOutputDevice = deviceId;
            var deviceName = AvailableOutputDevices.FirstOrDefault(d => d.Id == deviceId)?.Name ?? "Unknown";
            Snackbar.Add($"Output device changed to: {deviceName}", Severity.Success);
            Logger.LogInformation("Output device changed to: {DeviceId}", deviceId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error changing output device");
            Snackbar.Add("Error changing output device", Severity.Error);
        }
    }

    private async Task LoadCastDevices()
    {
        try
        {
            var devices = await CastAudioOutput.DiscoverDevicesAsync();
            AvailableCastDevices = devices.Select(d => d.Name).ToList();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading cast devices");
            Snackbar.Add("Error loading cast devices", Severity.Error);
        }
    }

    private async Task OnVolumeChanged(int volume)
    {
        try
        {
            Volume = volume;
            await AudioPlayer.SetVolumeAsync(SelectedInput, volume / 100f);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error changing volume");
            Snackbar.Add("Error changing volume", Severity.Error);
        }
    }

    private async Task OnInputChanged(string newInput)
    {
        try
        {
            if (SelectedInput != newInput)
            {
                await AudioPlayer.StopAsync(SelectedInput);
                SelectedInput = newInput;
                await SelectedInputChanged.InvokeAsync(newInput);
                if (IsPlaying)
                {
                    await PlayCurrentSource();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error changing input");
            Snackbar.Add("Error changing input", Severity.Error);
        }
    }

    private async Task OnOutputChanged(string newOutput)
    {
        try
        {
            if (SelectedOutput != newOutput)
            {
                SelectedOutput = newOutput;
                if (IsPlaying)
                {
                    await AudioPlayer.StopAsync(SelectedInput);
                    if (newOutput == "Cast")
                    {
                        await CastAudioOutput.StartAsync(AudioPlayer);
                    }
                    else
                    {
                        await CastAudioOutput.StopAsync();
                    }
                    await PlayCurrentSource();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error changing output");
            Snackbar.Add("Error changing output", Severity.Error);
        }
    }

    private Stream GetLocalFileStream()
    {
        // TODO: Implement a way to select and stream local audio files.
        return new MemoryStream();
    }
}
